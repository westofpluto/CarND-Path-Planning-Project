# CarND-Path-Planning-Project
Udacity Self-Driving Car Engineer Nanodegree Program, Term 3, Project 1

### Project Summary

The purpose of this project was to develop self-driving lane-management software that drives a vehicle around a simulated track, changing lanes as necessary to avoid other cars in the road. This software runs as a real-time controller that feeds inputs tothe Udacity self-driving car simulator. The project required that the simulated car must drive at least one loop (4.32 miles) around the track while staying within maximum acceleration and jerk limitations.

The code in this repo successfully met those requirements. I posted a [video of the car driving more than one lap around the track](https://youtu.be/-LQDm5lD8TA) and included that video (video-output-final.mp4) in this repo. My path planner consisted of a finite state machine-based behavior manager that determined whether to stay in this lane, follow the (slower) car ahead, or change lanes to pass teh car ahead. A trajectory controller used decisions from the bahvior planner to sen actual steering and speed signals to the simulator. Since the simulator requires trajectory control points as control inputs, I used a spline package to specifiy the near-term desired trajectory that was sent to the simulator. The following section describes the implementation in more detail.

###Code and Implementation Overview

My implementation used a number of files as follows:

* main.cpp: This file contains the main program for the path planning sofwtare, which communicates through a socket connection to the simulator. Every 0.02 seconds, the simulator sends navigation sensor information over the socket, the main program reads this, calls functions in the path planner to determine the control trajectory of the vehicle, then sends that control trajectory back over the socket to the simulator.
* vehicle.cpp: This file contains classes that represent vehicles/cars on the road. A subclass of Vehicle is called EgoVehicle and tha represents the car we are trying to control.
* other_vehicles.cpp: This file contains code that acts as a container for all the other vehicles on the road. This class was useful as an object to pass to the behavior planner.
* behavior.cpp: This file contains a finite-state-machine implementation of the behavior planner. The FSM contains only 3 states: DRIVE FORWARD, FOLLOW CAR AHEAD, and CHANGE LANE. Lane changes can be to the lane to the left or to the right (depending of course upon which lane the car is currently driving in). The car begins in the DRIVE FORWARD state and tries to speed up to a speed just under the speed limit (just under 50 MPH). If/when the car detects that there is a car ahead that is going slower, the car will switch into the FOLLOW CAR AHEAD state where it slows its speed to match that of the car ahead. As soon as it enters this state, it starts looking for opportunities to switch lanes. In order to switch lanes, it must detect that neither the car ahead in the desired lane nor the car behind in the other lane are too close to the ego vehicle to allow a lane change. The behavior software also has a sanity check function that checks to see if there is any vehicle in the set of other vehicles that is too close to the ego vehicle to allow a lane change. When the ego vehicle detects that it can safely change lanes, it changes state to CHANGE LANE. As soon as the lane change maneuver is completed, the tate switches back to either DRIVE FORWARD or FOLLOW CAR AHEAD depending on the state of any car ahead of the ego vehicle in the new lane.
* control.cpp: For every state of the vehicle specified in behavior.cpp, the file control.cpp specifies a desired control trajectory that implements the behavior of the given state. The control trajectories use some widely spaced desired control points and use a spline class (in spline.h) to interpolate near term control points from that trajectory. Control points are always appended to the end of the prior trajectory which is sent back from the simulator. Note that the choice of number of control points is important: too few control points and the car's trajectory becomes choppy, but too many control points results in too much control lag leading to ego vehicle trajectory instability.I ended up choosing 40 control points which results in a control trajectory of approximately 0.8 seconds in duration. This is of course recomputed every 0.02 seconds, so the resulting closed loop controller performs vehicle control that easily meets the project requirements.
* utils.cpp: The original main.cpp file contained a numer of utility functions for converting back and forth between map coordinates and Frenet coordinates. I moved these functions into a separet file called utils.cpp
* spline.h: This file implements the spline class that was used for spline interpolation.
* constants.h: This file contains a number of the constant parameters used in the controller. This includes such items as the number of control points, the min safe distace values, speed limit, etc.

At each time step, my code executes the following steps:
* Start by extracting the sensor data for the ego vehicle and other vehicles in order to set the current positions and velocities of all vehicles.
* Next, the state information for the ego vehicle and other vehicles is passed to the behaviro state machine through the method chooseNextState. In the states DRIVE FORWARD or FOLLOW CAR AHEAD, the chooseNextState method calls the method handle_drive_forward_behavior which sets the desired speed (used in the controller) and checks to see if we need to slow down due to a vehicle ahead in this lane. If the vehicle is currently in the FOLLOW CAR AHEAD state, then the chooseNextState method looks to see if it is appropriate to switch to the CHANGE LANE state. To switch safely, several facts must hold. The method isAnyCarTooClose is first called to see if there is any car that might prevent us from switching to that lane. Next the code focuses on cars that might be ahead or behind in the desired lane and checks their speeds to see if we even want to switch to that lane. (For example, if the car ahead in the other lane is going slower than the car ahead in our current lane, there is no good reason to switch lanes). If the car ahead and car behind in the other two lanes satisfy some basic safety conditions then the behavior module will switch state to the CHANGE LANE state. If the car is already in the CHANGE LANE state, the car calls the handle_change_lane_behavior method to determine the proper control speed depending on the cars ahead in both the current and desired lanes.
* The result of the behavior module is both a current vehicle state machine state and a desired/control speed. These are passed to the controller, which takes this information, uses the spline class to interpolate a control trajectory, and sends this to the simulator.
   